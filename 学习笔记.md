1. 解释器

```python
#! /usr/bin/env python
```

2. 编程风格

* 缩进统一

* 变量

第一个字母是字母或者下划线  

其他可以是字母 下划线  数字   

大小写敏感   

3. 变量类型 按特征分类

* 整型  

标准整型   长整型以L结尾

* 非整型

双精度浮点数   复数     decimal

* 序列类型

字符串 str  列表 list  元组 tuple

* 映像类型

字典 dict  

* 集合类型

可变集合 set    不可变集合  frozenset  

* 布尔类型 

True  False  

4. Python按可变性划分

可哈希的不可变数据类型  

数字  字符串  元组   frozenSet

可变数据类型  

字典dict  列表list  可变集合set 

5. 算术运算符

* +  加  

* -   减

* \*   乘

* /  除

* %  求余

* \*\*  幂

* // 取整除

6. 比较运算符  

*  == 等于

*  !=  <>  不等于 后者逐步淘汰

*  \>  大于

*  \<  小于

* \>=  大于等于

* \<=  小于等于

7. 逻辑运算符

* and 

* or

* not 

8. 按位运算符 

* & 

* |

* ^ 异或

* - 取反

* \<\<  左移  右边补0

* \>\>  右移  带符号右移

8. 成员运算符

* in 

* not in

9. 身份运算符

身份运算符用于比较两个对象的存储单元  

* is 是判断两个标识符是不是引用自一个对象

* is not 是判断两个标识符是不是引用自不同对象

02.py

10. 赋值运算符

*  =

*  +=

*  -=

*  *=

*  /=

*  %=

*  **=

*  //=

11. 注释

* 单行注释  #

* 多行注释  三个单引号  

12. 字符编码

* Python中默认的编码格式是 ASCII 格式

* 字符声明

```
# -*- coding: UTF-8 -*-
#coding=utf-8 
```
Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码  

```python
name = u'学习'
# 指定编码是unicode

name = name.encode('utf-8')
# 转换为utf-8编码

name = name.decode('utf-8')
# 从utf-8转换为unicode编码

```

unicode：简单粗暴，所有字符都是2Bytes，优点是字符->数字的转换速度快，缺点是占用空间大   

unicode常用2个字节（16位二进制）代表一个字符，生僻字需要用4个字节   

utf-8：精准，对不同的字符用不同的长度表示，优点是节省空间，缺点是：字符->数字的转换速度慢，因为每次都需要计算出字符需要多长的Bytes才能够准确表示   

内存中使用的编码是unicode，用空间换时间（程序都需要加载到内存才能运行，因而内存应该是尽可能的保证快）   
硬盘中或者网络传输用utf-8，网络I/O延迟或磁盘I/O延迟要远大与utf-8的转换延迟，而且I/O应该是尽可能地节省带宽，保证数据传输的稳定性   

计算机由美国人发明，最早的字符编码为ASCII，只规定了英文字母数字和一些特殊字符与数字的对应关系。

ascii用1个字节（8位二进制）代表一个字符

unicode常用2个字节（16位二进制）代表一个字符，生僻字需要用4个字节

如果我们的文档通篇都是英文，你用unicode会比ascii耗费多一倍的空间，在存储和传输上十分的低效

本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间  

无论是何种编辑器，要防止文件出现乱码  
核心法则就是，文件以什么编码保存的，就以什么编码方式打开  

## 程序的执行
python test.py   （我再强调一遍，执行test.py的第一步，一定是先将文件内容读入到内存中）

### 阶段一：启动python解释器

### 阶段二：python解释器此时就是一个文本编辑器，负责打开文件test.py,即从硬盘中读取test.py的内容到内存中

此时，python解释器会读取test.py的第一行内容，#coding:utf-8，来决定以什么编码格式来读入内存，这一行就是来设定python解释器这个软件的编码使用的编码格式这个编码，

可以用sys.getdefaultencoding()查看，如果不在python文件指定头信息＃-*-coding:utf-8-*-,那就使用默认的   

python2中默认使用ascii，python3中默认使用utf-8

### 阶段三：读取已经加载到内存的代码（unicode编码的二进制），然后执行，执行过程中可能会开辟新的内存空间，比如x="egon"

内存的编码使用unicode，不代表内存中全都是unicode编码的二进制，

在程序执行之前，内存中确实都是unicode编码的二进制,比如从文件中读取了一行x="egon",其中的x，等号，引号，地位都一样，都是普通字符而已，都是以unicode编码的二进制形式存放与内存中的

但是程序在执行过程中，会申请内存（与程序代码所存在的内存是俩个空间），可以存放任意编码格式的数据，比如x="egon",会被python解释器识别为字符串，会申请内存空间来存放"hello"，然后让x指向该内存地址，此时新申请的该内存地址保存也是unicode编码的egon,如果代码换成x="egon".encode('utf-8'),那么新申请的内存空间里存放的就是utf-8编码的字符串egon了

13. 导入模块

* import moduleName

* from module1 import module11

* import moduleName as newName

14. 系统交互

* import os  os.popen('command').read()

* import commands  commands.getstatusoutput('command')

* import sys  sys.argv

15. 用户交互

* raw_input(提示语)  都是字符串

* input(提示语)

* raw_input与input的区别   raw_input返回都是字符串  input根据原始格式来判断 

16. 流程控制

* if else

```python
if ():
  code
else:
  code

if ():
  code
elif():
  code
else:
  code

```
* while
```python
while ():
  code
```

* for 

```python
for iterating_var in sequence:
   statements(s)
```
* 嵌套循环

```python
for iterating_var in sequence:
   for iterating_var in sequence:
      statements(s)
   statements(s)

while expression:
   while expression:
      statement(s)
   statement(s)

```

* break

在语句块执行过程中终止循环，并且跳出整个循环  


* continue

在语句块执行过程中终止循环，并且跳出整个循环

* pass 

在语句块执行过程中终止循环，并且跳出整个循环

17. 文件处理

* f = file(fileName, mod)

mod r read  w write a append  

w 如果文件不存在 先创建一个文件  如果文件存在  清空文件的内容  

* for line in f.readlines():

* f.write(content) 在内存缓冲区  如果内容小于1024个字符 大于1024个字符 就写硬盘一次

* f.flush()  强制写入硬盘中

* f.closed 状态位

* f.close() 关闭文件

* f.encoding 字符集

python2 存储文件是ascii  内存中unicode  

python3 存储文件utf-8    内存中unicode  

* f.write(u'字符集'.encode('utf-8'))

* f.isatty()

终端在linux就是一个文件

* f.mod

* f.readline()

* f.readlines()  以列表方式读取

* f.next()

* f.read()  以字符串方式读取
当读取一次后 给文件写入内容 如果  
再读取一次 这时候读取的开始位置 上一次的结束位置  


* f.seek(offset, whence)  跳转文件的游标 单位:字节数

whence: 0 1 2  
f.seek(0) 回到文件开头    

f.seek(2) 回到文件结尾  

f.seek(1) 文件当前位置  

* f.tell()  文件当前的位置

* f.truncate(size)  截取文件  size 单位 字节

从开头开始截取  无论当前位置在哪  

* f.writelines(arg)  写多行

arg 列表 等  

* f.xreadlines()  逐行读

* mod 权限

```
r+  读写模式

w+  写读模式

a+  追加读模式

r+b  读写模式 二进制  

w+b  写读模式 二进制 

a+b  追加读模式 二进制 

因为windows换行是\r\n  linux换行是\n

为了同时兼容linux 和 windows
以后统一加b
用二进制方式

```

18. 字符串

* find()

* rfind()

* index()

查找不到 会报错

* rindex()

* count()

* lowercase()

* capitalize()

* lower()

* upper()

* swapcase()

* split(seperate)

* join()

* len()

* cmp() 第一个大 返回1

* max()  寻找最大字符 

* min()  寻找最小字符

* startwith()

* endwith()

18. 列表

* list  []

* append()

* inert(index, content)

* remove() 删除

* count()

* find()

* index(content, start) 找到第一个就返回

* pop()

* extend()  在列表末尾一次性追加另一个序列中的多个值

* reverse()

* sort()

* list[start:end] 不包含end

从后取的时候 index是从-1开始 start必须小于end

* list[start::step] 

19. 元组

* 常量数组  不可修改

* 列表和元组可以互相转换

* tuple = (,)

* [] 操作符访问元素 


20. 字典dict

* 键值对 逗号分隔  

* get(key)   如果key不存在 返回值0 不会报Error

* has_key()

* keys()

* values()

* items()    for key ,value  in d.items()

* for i in dict:  遍历字典

* d1.update(d2)   d1合并d2字典  键名相同 d2覆盖d

* d.pop(key)  删除指定键值对   返回值指定删除键的键值

* d.popitem()  从前面删除一个键值对  返回值是元组

* d.clear()  清空字典  del d

* d.copy()

* d.cmp(dict1,dict2)  比较字典 优先级为元素个数  键大小  键值大小  第一个大返回1  小返回-1 一样返回0

* dictionary复制

```python

d1 = d2 #别名  指向同一个对象

d2 = dict.copy() #克隆 即浅拷贝

```

* iteritems()  iter---生成器

* iterkeys()  iter---生成器

* itervalues()  iter---生成器

* setdefault(key， value)  key的值已经存在 value不会生效

21. list dict

* dict 查找与插入极快 不会随着key增加而增加

* list 查找与插入会随着元素增加而增加

* dict 需要大量内存 内存浪费多

* list  占用空间小  浪费内存少

* dict  key 不可变

* list 通过下标查询

* dict 无序  list 有序

> python中list对象的存储结构采用的是线性表，因此其查询复杂度为O(n),而dict对象的存储结构采用的是散列表(hash表)，其在最优情况下查询复杂度为O(1)

> python解释器就是基于c写的，这个两个数据结构应该对应c的哈希表和数组。

> 因为哈希表需要额外内存记录映射关系，而数组只需要通过索引就能计算出下一个节点的位置，所以哈希表占用的内存比数组大，也就是dict比list占用的内存大些。

22. set 集合

* 无序  元素不重复  

* 功能: 关系测试  去重

* set = {,}

* add()

* set(list)  通过list生成一个集合

* set集合运算

* a & b  交集  a.intersection(b)

* a | b  并集  a.union(b)

* a - b  差集  a.difference(b)

* a ^ b  对称差集  a.symmetric_difference(b)

> 对称差集定义为集合A与集合B中所有不属于A∩B的元素的集合

* a.issubset(b)    a是b的子集 

* a.issuperset(b)  a是否包含b


23. 包文件 package

包是文件夹  该文件夹下必须有一个__init__.py


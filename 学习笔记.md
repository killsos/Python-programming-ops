1. 解释器

```python
#! /usr/bin/env python
```

2. 编程风格

* 缩进统一

* 变量

第一个字母是字母或者下划线  

其他可以是字母 下划线  数字   

大小写敏感   

3. 变量类型 按特征分类

* 整型  

标准整型   长整型以L结尾

* 非整型

双精度浮点数   复数     decimal

* 序列类型

字符串 str  列表 list  元组 tuple

* 映像类型

字典 dict  

* 集合类型

可变集合 set    不可变集合  frozenset  

* 布尔类型 

True  False  

4. Python按可变性划分

可哈希的不可变数据类型  

数字  字符串  元组   frozenSet

可变数据类型  

字典dict  列表list  可变集合set 

5. 算术运算符

* +  加  

* -   减

* \*   乘

* /  除

* %  求余

* \*\*  幂

* // 取整除

6. 比较运算符  

*  == 等于

*  !=  <>  不等于 后者逐步淘汰

*  \>  大于

*  \<  小于

* \>=  大于等于

* \<=  小于等于

7. 逻辑运算符

* and 

* or

* not 

8. 按位运算符 

* & 

* |

* ^ 异或

* - 取反

* \<\<  左移  右边补0

* \>\>  右移  带符号右移

8. 成员运算符

* in 

* not in

9. 身份运算符

身份运算符用于比较两个对象的存储单元  

* is 是判断两个标识符是不是引用自一个对象

* is not 是判断两个标识符是不是引用自不同对象

02.py

10. 赋值运算符

*  =

*  +=

*  -=

*  *=

*  /=

*  %=

*  **=

*  //=

11. 注释

* 单行注释  #

* 多行注释  三个单引号  

12. 字符编码

* Python中默认的编码格式是 ASCII 格式

* 字符声明

```
# -*- coding: UTF-8 -*-
#coding=utf-8 
```
Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码  

```python
name = u'学习'
# 指定编码是unicode

name = name.encode('utf-8')
# 转换为utf-8编码

name = name.decode('utf-8')
# 从utf-8转换为unicode编码

```

unicode：简单粗暴，所有字符都是2Bytes，优点是字符->数字的转换速度快，缺点是占用空间大   

unicode常用2个字节（16位二进制）代表一个字符，生僻字需要用4个字节   

utf-8：精准，对不同的字符用不同的长度表示，优点是节省空间，缺点是：字符->数字的转换速度慢，因为每次都需要计算出字符需要多长的Bytes才能够准确表示   

内存中使用的编码是unicode，用空间换时间（程序都需要加载到内存才能运行，因而内存应该是尽可能的保证快）   
硬盘中或者网络传输用utf-8，网络I/O延迟或磁盘I/O延迟要远大与utf-8的转换延迟，而且I/O应该是尽可能地节省带宽，保证数据传输的稳定性   

计算机由美国人发明，最早的字符编码为ASCII，只规定了英文字母数字和一些特殊字符与数字的对应关系。

ascii用1个字节（8位二进制）代表一个字符

unicode常用2个字节（16位二进制）代表一个字符，生僻字需要用4个字节

如果我们的文档通篇都是英文，你用unicode会比ascii耗费多一倍的空间，在存储和传输上十分的低效

本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间  

无论是何种编辑器，要防止文件出现乱码  
核心法则就是，文件以什么编码保存的，就以什么编码方式打开  

## 程序的执行
python test.py   （我再强调一遍，执行test.py的第一步，一定是先将文件内容读入到内存中）

### 阶段一：启动python解释器

### 阶段二：python解释器此时就是一个文本编辑器，负责打开文件test.py,即从硬盘中读取test.py的内容到内存中

此时，python解释器会读取test.py的第一行内容，#coding:utf-8，来决定以什么编码格式来读入内存，这一行就是来设定python解释器这个软件的编码使用的编码格式这个编码，

可以用sys.getdefaultencoding()查看，如果不在python文件指定头信息＃-*-coding:utf-8-*-,那就使用默认的   

python2中默认使用ascii，python3中默认使用utf-8

### 阶段三：读取已经加载到内存的代码（unicode编码的二进制），然后执行，执行过程中可能会开辟新的内存空间，比如x="egon"

内存的编码使用unicode，不代表内存中全都是unicode编码的二进制，

在程序执行之前，内存中确实都是unicode编码的二进制,比如从文件中读取了一行x="egon",其中的x，等号，引号，地位都一样，都是普通字符而已，都是以unicode编码的二进制形式存放与内存中的

但是程序在执行过程中，会申请内存（与程序代码所存在的内存是俩个空间），可以存放任意编码格式的数据，比如x="egon",会被python解释器识别为字符串，会申请内存空间来存放"hello"，然后让x指向该内存地址，此时新申请的该内存地址保存也是unicode编码的egon,如果代码换成x="egon".encode('utf-8'),那么新申请的内存空间里存放的就是utf-8编码的字符串egon了

13. 导入模块

* import moduleName

* from module1 import module11

* import moduleName as newName

14. 系统交互

* import os  os.popen('command').read()

* import commands  commands.getstatusoutput('command')

* import sys  sys.argv

15. 用户交互

* raw_input(提示语)  都是字符串

* input(提示语)

* raw_input与input的区别   raw_input返回都是字符串  input根据原始格式来判断 

16. 流程控制

* if else

```python
if ():
  code
else:
  code

if ():
  code
elif():
  code
else:
  code

```
* while
```python
while ():
  code
```

* for 

```python
for iterating_var in sequence:
   statements(s)
```
* 嵌套循环

```python
for iterating_var in sequence:
   for iterating_var in sequence:
      statements(s)
   statements(s)

while expression:
   while expression:
      statement(s)
   statement(s)

```

* break

在语句块执行过程中终止循环，并且跳出整个循环  


* continue

在语句块执行过程中终止循环，并且跳出整个循环

* pass 

在语句块执行过程中终止循环，并且跳出整个循环